#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class erdakte {
public:
	string qsmrkjzxdfpv;
	double nxytwftriayhs;
	erdakte();
	void hruzakunmyxt();

protected:
	int srqbdbbnsc;
	string aikditxoie;

	bool vruupcijeqbkz(string iembvkgsbquzw, string vpblbeexeml, int trmejfjrlzmttr, double awaru, int ojdqonayfwb);
	int ivvndpoiasrpmnvzcpxnbpwi(double gwrfafzcor, double lyfabbnyzdmhy, double ztwpfibtbnjw, bool npfnjduuiwelkw, double jktuvocxxa, double jizmiswldbueo, bool asqbsgvavy, bool syulgoydvyfe, double hkemiwm, int yzupspyzt);
	int hphmqjgneczx(string gwqzxyhx, int mmblcbz, double pujbbqptmmtq);
	int shtgcpszjeuvkiaiwu();
	double ekftozlxivykruwhk(bool pjynyqe, double kfrjawbq, string pnzmaomvdgcixz, int lapouyva, double yccsisg, bool sgsxtjajqsxbk, string bgutwatjqmku, int wzxkhgahqdh);
	string fgocvqwneotmshxivaowrjz(int tolfiqes, int rcqkeovabwvhsi, bool gqglcgmykwys, double mjyxmb, string egnrmmneevx, double wsnrogncswgq, int utptuacfuibfv, string qziakogz, double hzukubtnjcy, int yepsyksd);

private:
	int wtugpbcvzxwbc;
	string xitgo;

	double aoqbkoxumwfdkpktya(double mzfylgvv, int vjroibpka, string bxmgjlrsoev, string rbkjqgpaladrn);
	void zsboqizhnhioxavqzyuz();
	void qwrcsfxaacjmrhqtgbag(double sbtbdvwyayasxcb, double ztotnnbexjhh, int lqgwdexuo, int haareokqe, double qjzbpind, double qbswoyreytl, string ylhfqzknjolsq);
	string soparkyldktcpllnxg(bool tqooiyhsef, string sxzuur, double eixrayv, bool zdhnxqwb, double oiklsxw, string hnjipni, int beskq, int tebfzzmjwxkzzrp);
	int eqnzpbfvqh();
	void lectbvifxxsxelvu(string cbmbjozmucz);
	int bjbfojegglqb(bool lubqiylkwcc);

};


double erdakte::aoqbkoxumwfdkpktya(double mzfylgvv, int vjroibpka, string bxmgjlrsoev, string rbkjqgpaladrn) {
	double lrvqxumysldhzm = 3273;
	bool cobcqzrh = true;
	string jkpftbcj = "qudytnjyprprj";
	return 11640;
}

void erdakte::zsboqizhnhioxavqzyuz() {
	bool fiwftghxywtlm = true;
	string zhsitlgeneb = "aixlyifeqyrwicngmncxoizatcmqy";
	double idwukg = 15834;

}

void erdakte::qwrcsfxaacjmrhqtgbag(double sbtbdvwyayasxcb, double ztotnnbexjhh, int lqgwdexuo, int haareokqe, double qjzbpind, double qbswoyreytl, string ylhfqzknjolsq) {
	int vgvrpbapwhsb = 1218;
	string huwibbp = "shjlrxfvgufkerersgfghgexbklhzbzojjqetuahdbhdepnxduwtstesdm";
	bool wtccpvwvtcgbr = true;
	double zldttmqbiwv = 967;
	string pwcvjhnx = "mdainvvomzzuvjygnuibqhgfjkbhlsvbtjrzpuekuggxvskjrqzippyrca";
	if (967 == 967) {
		int xkyj;
		for (xkyj = 47; xkyj > 0; xkyj--) {
			continue;
		}
	}

}

string erdakte::soparkyldktcpllnxg(bool tqooiyhsef, string sxzuur, double eixrayv, bool zdhnxqwb, double oiklsxw, string hnjipni, int beskq, int tebfzzmjwxkzzrp) {
	bool pvjfyd = true;
	bool hkrmbwosjyy = true;
	string kslccsxsls = "iqwunvhkrtgaejimkoahhjgopyhrucjl";
	string ikgtisgvueexy = "hsrppvarzuvihowzmanaqgdkzpcvviwxrfmyrzipastrjdzvftwleladtlqsnxcmmosinkwtbz";
	int cgpkwsm = 8723;
	int qrrbrrxkocmq = 1219;
	bool fmdeondkvtd = true;
	bool wjdkp = false;
	int ndgirmwokamxzfj = 1663;
	string waccwrrfkzahjc = "ldhxjzxtqfojswnfqlfxdmcelqu";
	if (true != true) {
		int mwgcfy;
		for (mwgcfy = 21; mwgcfy > 0; mwgcfy--) {
			continue;
		}
	}
	if (8723 == 8723) {
		int dqwnmspfh;
		for (dqwnmspfh = 98; dqwnmspfh > 0; dqwnmspfh--) {
			continue;
		}
	}
	if (1219 != 1219) {
		int zxofq;
		for (zxofq = 66; zxofq > 0; zxofq--) {
			continue;
		}
	}
	return string("zxawuldleno");
}

int erdakte::eqnzpbfvqh() {
	int bjvanbjcv = 5441;
	bool phomjaaxjq = false;
	if (5441 != 5441) {
		int uhzuck;
		for (uhzuck = 1; uhzuck > 0; uhzuck--) {
			continue;
		}
	}
	if (false != false) {
		int xlisp;
		for (xlisp = 59; xlisp > 0; xlisp--) {
			continue;
		}
	}
	return 58897;
}

void erdakte::lectbvifxxsxelvu(string cbmbjozmucz) {
	double zagonvgqxgr = 14154;
	int ukooqfegyda = 3014;
	double kdbnntd = 36034;
	if (36034 != 36034) {
		int ngtir;
		for (ngtir = 49; ngtir > 0; ngtir--) {
			continue;
		}
	}
	if (3014 != 3014) {
		int wtqcaftnn;
		for (wtqcaftnn = 36; wtqcaftnn > 0; wtqcaftnn--) {
			continue;
		}
	}
	if (36034 == 36034) {
		int kcrcvl;
		for (kcrcvl = 41; kcrcvl > 0; kcrcvl--) {
			continue;
		}
	}

}

int erdakte::bjbfojegglqb(bool lubqiylkwcc) {
	bool fbpxdnlxomsj = false;
	bool dajfjarhamnaf = false;
	string tzdkow = "myojvtfipdrczceqxnauoqdvkcpimxmdiigonftctzswxinol";
	double zdhsph = 74921;
	if (false == false) {
		int vkrs;
		for (vkrs = 39; vkrs > 0; vkrs--) {
			continue;
		}
	}
	if (74921 != 74921) {
		int qrlgrqor;
		for (qrlgrqor = 61; qrlgrqor > 0; qrlgrqor--) {
			continue;
		}
	}
	if (false == false) {
		int rxb;
		for (rxb = 81; rxb > 0; rxb--) {
			continue;
		}
	}
	return 73684;
}

bool erdakte::vruupcijeqbkz(string iembvkgsbquzw, string vpblbeexeml, int trmejfjrlzmttr, double awaru, int ojdqonayfwb) {
	string ybjxvakaohbo = "lmqvymvjpvvyhkltzndqzxtvlkncijmzkkogmigcewxxeyxrswjnimwwicfmthjxknijjfqfcyxtwerpbitvxqbtdodxqxftjwms";
	string zhadbmztpg = "ifrmsvliqyqskqeayispkhlbm";
	bool olzutxd = false;
	int fchryxatcmuprp = 2492;
	bool cggyzcrgoum = true;
	bool qcdym = false;
	double silqfehcz = 32961;
	if (false == false) {
		int tbiizvbo;
		for (tbiizvbo = 63; tbiizvbo > 0; tbiizvbo--) {
			continue;
		}
	}
	if (string("lmqvymvjpvvyhkltzndqzxtvlkncijmzkkogmigcewxxeyxrswjnimwwicfmthjxknijjfqfcyxtwerpbitvxqbtdodxqxftjwms") != string("lmqvymvjpvvyhkltzndqzxtvlkncijmzkkogmigcewxxeyxrswjnimwwicfmthjxknijjfqfcyxtwerpbitvxqbtdodxqxftjwms")) {
		int nrut;
		for (nrut = 74; nrut > 0; nrut--) {
			continue;
		}
	}
	if (string("lmqvymvjpvvyhkltzndqzxtvlkncijmzkkogmigcewxxeyxrswjnimwwicfmthjxknijjfqfcyxtwerpbitvxqbtdodxqxftjwms") != string("lmqvymvjpvvyhkltzndqzxtvlkncijmzkkogmigcewxxeyxrswjnimwwicfmthjxknijjfqfcyxtwerpbitvxqbtdodxqxftjwms")) {
		int vdwvu;
		for (vdwvu = 36; vdwvu > 0; vdwvu--) {
			continue;
		}
	}
	if (true != true) {
		int xogmqezkai;
		for (xogmqezkai = 30; xogmqezkai > 0; xogmqezkai--) {
			continue;
		}
	}
	return false;
}

int erdakte::ivvndpoiasrpmnvzcpxnbpwi(double gwrfafzcor, double lyfabbnyzdmhy, double ztwpfibtbnjw, bool npfnjduuiwelkw, double jktuvocxxa, double jizmiswldbueo, bool asqbsgvavy, bool syulgoydvyfe, double hkemiwm, int yzupspyzt) {
	int npnltq = 4199;
	int yqlwdcypdyoo = 1452;
	int enpkm = 4873;
	if (4199 != 4199) {
		int ycdqen;
		for (ycdqen = 2; ycdqen > 0; ycdqen--) {
			continue;
		}
	}
	if (4199 != 4199) {
		int jsjb;
		for (jsjb = 8; jsjb > 0; jsjb--) {
			continue;
		}
	}
	if (4199 == 4199) {
		int dnqnt;
		for (dnqnt = 81; dnqnt > 0; dnqnt--) {
			continue;
		}
	}
	if (4199 != 4199) {
		int fpqbblcakw;
		for (fpqbblcakw = 95; fpqbblcakw > 0; fpqbblcakw--) {
			continue;
		}
	}
	return 50216;
}

int erdakte::hphmqjgneczx(string gwqzxyhx, int mmblcbz, double pujbbqptmmtq) {
	return 74333;
}

int erdakte::shtgcpszjeuvkiaiwu() {
	bool ryfvpudt = true;
	bool cwzpsydls = false;
	int hqsfbf = 5224;
	bool epqrlc = true;
	int njxvaj = 3318;
	double pvcqmyfaztb = 17113;
	int ycqtfotx = 6302;
	int bgrcku = 268;
	return 93568;
}

double erdakte::ekftozlxivykruwhk(bool pjynyqe, double kfrjawbq, string pnzmaomvdgcixz, int lapouyva, double yccsisg, bool sgsxtjajqsxbk, string bgutwatjqmku, int wzxkhgahqdh) {
	string cbswzgaujtpxsyb = "egetpcpqfqookxndhilolynmotoprohwthmxlkcisncyrwfravzyyfithdjolwrfrdeoewhwqtwbmwiatcsaqhanjscokaxixkl";
	double kgqcilgetzrpwmb = 69019;
	int kcijdgxqydxp = 3211;
	string vptxtz = "lczgdmpjetbrdbgmnbwgigajyxhpmnhhoqvtcbgdwnlngtfnvtkfdciohcyzmxmr";
	bool lqtkyksvqeo = false;
	if (69019 != 69019) {
		int xmjevekbk;
		for (xmjevekbk = 44; xmjevekbk > 0; xmjevekbk--) {
			continue;
		}
	}
	if (false == false) {
		int fognjm;
		for (fognjm = 91; fognjm > 0; fognjm--) {
			continue;
		}
	}
	if (false != false) {
		int kyqovtkq;
		for (kyqovtkq = 62; kyqovtkq > 0; kyqovtkq--) {
			continue;
		}
	}
	return 71725;
}

string erdakte::fgocvqwneotmshxivaowrjz(int tolfiqes, int rcqkeovabwvhsi, bool gqglcgmykwys, double mjyxmb, string egnrmmneevx, double wsnrogncswgq, int utptuacfuibfv, string qziakogz, double hzukubtnjcy, int yepsyksd) {
	double dgsbkhewobyhta = 4713;
	bool zagfhsr = true;
	bool ivpahioxfynek = false;
	double pkpftpkfuoglce = 84563;
	int hnyneyrjeos = 1123;
	return string("bihlte");
}

void erdakte::hruzakunmyxt() {
	string eirrpuesa = "ppkkmmtrlblmnakqwbbzglhckjkgjcpwdtdoybpscmvrjeqgjbpygfstylsnmgxnkjhxonyrlpfrkkigxiypduejgkdubjnoe";
	bool kwxktkrspxf = false;
	bool ouiyhylextmuop = true;
	int xoeunnjr = 2062;
	double eqclrimuothfj = 54416;
	if (2062 == 2062) {
		int fxhmsybirt;
		for (fxhmsybirt = 11; fxhmsybirt > 0; fxhmsybirt--) {
			continue;
		}
	}
	if (false != false) {
		int qslntov;
		for (qslntov = 73; qslntov > 0; qslntov--) {
			continue;
		}
	}

}

erdakte::erdakte() {
	this->hruzakunmyxt();
	this->vruupcijeqbkz(string("ydbttipbkfmfrwvcdyuqvfrhgggp"), string("emffcuprtfgzcqukoeobtbjipairzusuyrknnlkuumcjyyohccatsfqvuinkaspllemlcdg"), 4920, 38101, 675);
	this->ivvndpoiasrpmnvzcpxnbpwi(6015, 45229, 19009, true, 21229, 4845, false, true, 24308, 1479);
	this->hphmqjgneczx(string("ngiuzmxuilchryuumclhlzefhbpxyqzfveumarlvzfpsqcgfnhoelbeobcsxhtgbgeacyjwcifuxlxvuvera"), 7333, 8891);
	this->shtgcpszjeuvkiaiwu();
	this->ekftozlxivykruwhk(true, 62782, string("kcpenskdwjhdoasfsbktakulhgvkqamljplmxzuwmhzijeydiyaupajshggddrbeynzzqnhbruzmtbdujaqcpfckchcw"), 335, 43218, true, string("bextvtjrijjotgmowwxhtpjyygnrppuruvaqipqpfaekgnxovmxktaasbt"), 3118);
	this->fgocvqwneotmshxivaowrjz(2281, 1099, true, 36877, string("abhkdzrzctrkob"), 8035, 631, string("gaunnuskopdzczezdkwbxrqstwlepceoekoxafjjlrsdtuahtbpewjzpckdxrvcvrmzffgxrwufjxwatgs"), 56865, 997);
	this->aoqbkoxumwfdkpktya(36453, 5495, string("ehzwlyvhkpfvwakpqpumsbfhibnslwkpjntzydzulmnmbqmouvuvzmusikfgyrga"), string("vawkuzdsxcxekfyrivgupopnaskttiixuvwhnnswadewqiboutwlufycycjzlpkdfvnsyczeadawtelcbagginlzqmszl"));
	this->zsboqizhnhioxavqzyuz();
	this->qwrcsfxaacjmrhqtgbag(480, 17670, 8356, 7932, 7011, 33988, string("ixmudtskzurycueftjipmuwcaceaidmctvmjbjaidlhtfynmcwfhxapekrnblcknimydxwdfjxyzynogdmrlpankpkxgjgl"));
	this->soparkyldktcpllnxg(true, string("okjupelskddenzorooxyuhmspyeggxtyzocjvtktzssyearcfsphctftb"), 37911, false, 67790, string("tkplqrkigbx"), 1184, 1689);
	this->eqnzpbfvqh();
	this->lectbvifxxsxelvu(string("jugxndagvghupnbcgmkvjmxrmmqcrbubpiygycxkgtmxwceheiaejgktsheoejgwwibzdqanfnthxcpfh"));
	this->bjbfojegglqb(true);
}



#include "GrenadePrediction.h"
#include "Render.h"
void grenade_prediction::Tick(int buttons)
{
    if (!g_Options.Visuals.GrenadePrediction)
        return;
    bool in_attack = buttons & IN_ATTACK;
    bool in_attack2 = buttons & IN_ATTACK2;

    act = (in_attack && in_attack2) ? ACT_LOB :
        (in_attack2) ? ACT_DROP :
        (in_attack) ? ACT_THROW :
        ACT_NONE;
}
void grenade_prediction::View(CViewSetup* setup)
{

    auto local = g_EntityList->GetClientEntity(g_Engine->GetLocalPlayer());
    if (!g_Options.Visuals.GrenadePrediction)
        return;
    if (local && local->IsAlive())
    {
        CBaseCombatWeapon* weapon = (CBaseCombatWeapon*)g_EntityList->GetClientEntityFromHandle(local->GetActiveWeaponHandle());
        if (weapon && MiscFunctions::IsGrenade(weapon) && act != ACT_NONE)
        {
            type = weapon->m_AttributeManager()->m_Item()->GetItemDefinitionIndex();
            Simulate(setup);
        }
        else
        {
            type = 0;
        }
    }
}

void grenade_prediction::globalelite()
{

	/*----------START JUNK CODE----------*/
	bool JunkCode8779 = true;
	if (JunkCode8779 == true)
		JunkCode8779 = true;
	try {
		JunkCode8779 = true;
	}
	catch (...) {}
	bool While2974 = true;
	while (While2974 == true) {
		JunkCode8779 = false;
		While2974 = false;
	}
	bool While215 = true;
	while (While215 == true) {
		JunkCode8779 = true;
		While215 = false;
	}
	if (JunkCode8779 == false)
		JunkCode8779 = false;
	else
		JunkCode8779 = false;
	if (JunkCode8779 == true)
		JunkCode8779 = true;
	else
		JunkCode8779 = false;
	if (JunkCode8779 == true)
		JunkCode8779 = false;
	else
		JunkCode8779 = false;
	if (JunkCode8779 == true)
		JunkCode8779 = false;
	else
		JunkCode8779 = true;
	bool While4124 = true;
	while (While4124 == true) {
		JunkCode8779 = true;
		While4124 = false;
	}
	if (JunkCode8779 == false)
		JunkCode8779 = true;
	else
		JunkCode8779 = true;
	bool While5224 = true;
	while (While5224 == true) {
		JunkCode8779 = false;
		While5224 = false;
	}
	if (JunkCode8779 == false)
		JunkCode8779 = false;
	bool While682 = true;
	while (While682 == true) {
		JunkCode8779 = false;
		While682 = false;
	}
	try {
		JunkCode8779 = false;
	}
	catch (...) {}
	if (JunkCode8779 == false)
		JunkCode8779 = true;
	if (JunkCode8779 == false)
		JunkCode8779 = true;
	else
		JunkCode8779 = false;
	if (JunkCode8779 == true)
		JunkCode8779 = false;
	else
		JunkCode8779 = true;
	try {
		JunkCode8779 = true;
	}
	catch (...) {}
	if (JunkCode8779 == false)
		JunkCode8779 = true;
	else
		JunkCode8779 = false;
	bool While4822 = true;
	while (While4822 == true) {
		JunkCode8779 = true;
		While4822 = false;
	}
	bool While6784 = true;
	while (While6784 == true) {
		JunkCode8779 = false;
		While6784 = false;
	}
	if (JunkCode8779 == false)
		JunkCode8779 = false;
	if (JunkCode8779 == false)
		JunkCode8779 = false;
	try {
		JunkCode8779 = false;
	}
	catch (...) {}
	if (JunkCode8779 == true)
		JunkCode8779 = false;
	else
		JunkCode8779 = false;
	try {
		JunkCode8779 = false;
	}
	catch (...) {}
	if (JunkCode8779 == true)
		JunkCode8779 = false;
	if (JunkCode8779 == false)
		JunkCode8779 = true;
	else
		JunkCode8779 = false;
	if (JunkCode8779 == true)
		JunkCode8779 = true;
	else
		JunkCode8779 = false;
	if (JunkCode8779 == true)
		JunkCode8779 = false;
	else
		JunkCode8779 = true;
	try {
		JunkCode8779 = true;
	}
	catch (...) {}
	bool While9242 = true;
	while (While9242 == true) {
		JunkCode8779 = true;
		While9242 = false;
	}
	if (JunkCode8779 == true)
		JunkCode8779 = true;
	if (JunkCode8779 == false)
		JunkCode8779 = true;
	else
		JunkCode8779 = true;
	try {
		JunkCode8779 = true;
	}
	catch (...) {}
	if (JunkCode8779 == true)
		JunkCode8779 = false;
	try {
		JunkCode8779 = true;
	}
	catch (...) {}
	if (JunkCode8779 == true)
		JunkCode8779 = false;
	bool While9004 = true;
	while (While9004 == true) {
		JunkCode8779 = false;
		While9004 = false;
	}
	if (JunkCode8779 == false)
		JunkCode8779 = true;
	try {
		JunkCode8779 = true;
	}
	catch (...) {}
	if (JunkCode8779 == false)
		JunkCode8779 = false;
	else
		JunkCode8779 = true;
	try {
		JunkCode8779 = true;
	}
	catch (...) {}
	if (JunkCode8779 == false)
		JunkCode8779 = true;
	else
		JunkCode8779 = false;
	if (JunkCode8779 == false)
		JunkCode8779 = false;
	if (JunkCode8779 == true)
		JunkCode8779 = true;
	else
		JunkCode8779 = false;
	if (JunkCode8779 == false)
		JunkCode8779 = true;
	if (JunkCode8779 == true)
		JunkCode8779 = false;
	else
		JunkCode8779 = true;
	try {
		JunkCode8779 = true;
	}
	catch (...) {}
	if (JunkCode8779 == false)
		JunkCode8779 = true;
	if (JunkCode8779 == true)
		JunkCode8779 = false;
	if (JunkCode8779 == true)
		JunkCode8779 = true;
	bool While5628 = true;
	while (While5628 == true) {
		JunkCode8779 = true;
		While5628 = false;
	}
	try {
		JunkCode8779 = true;
	}
	catch (...) {}
	try {
		JunkCode8779 = true;
	}
	catch (...) {}
	if (JunkCode8779 == false)
		JunkCode8779 = true;
	else
		JunkCode8779 = true;
	if (JunkCode8779 == true)
		JunkCode8779 = true;
	if (JunkCode8779 == true)
		JunkCode8779 = false;
	else
		JunkCode8779 = false;
	bool While3619 = true;
	while (While3619 == true) {
		JunkCode8779 = true;
		While3619 = false;
	}
	if (JunkCode8779 == true)
		JunkCode8779 = false;
	bool While4694 = true;
	while (While4694 == true) {
		JunkCode8779 = false;
		While4694 = false;
	}
	if (JunkCode8779 == false)
		JunkCode8779 = false;
	try {
		JunkCode8779 = true;
	}
	catch (...) {}
	if (JunkCode8779 == false)
		JunkCode8779 = true;
	else
		JunkCode8779 = false;
	try {
		JunkCode8779 = false;
	}
	catch (...) {}
	bool While48 = true;
	while (While48 == true) {
		JunkCode8779 = false;
		While48 = false;
	}
	if (JunkCode8779 == true)
		JunkCode8779 = true;
	else
		JunkCode8779 = true;
	if (JunkCode8779 == false)
		JunkCode8779 = false;
	else
		JunkCode8779 = true;
	if (JunkCode8779 == false)
		JunkCode8779 = true;
	else
		JunkCode8779 = true;
	bool While6726 = true;
	while (While6726 == true) {
		JunkCode8779 = true;
		While6726 = false;
	}
	try {
		JunkCode8779 = true;
	}
	catch (...) {}
	if (JunkCode8779 == true)
		JunkCode8779 = false;
	bool While3768 = true;
	while (While3768 == true) {
		JunkCode8779 = false;
		While3768 = false;
	}
	if (JunkCode8779 == true)
		JunkCode8779 = true;
	else
		JunkCode8779 = false;
	try {
		JunkCode8779 = false;
	}
	catch (...) {}
	try {
		JunkCode8779 = true;
	}
	catch (...) {}
	try {
		JunkCode8779 = true;
	}
	catch (...) {}
	if (JunkCode8779 == false)
		JunkCode8779 = true;
	try {
		JunkCode8779 = false;
	}
	catch (...) {}
	if (JunkCode8779 == true)
		JunkCode8779 = true;
	/*----------END JUNK CODE----------*/


}

void grenade_prediction::Paint()
{
    if (!g_Options.Visuals.GrenadePrediction)
        return;
    if ((type) && path.size()>1)
    {
        Vector nadeStart, nadeEnd;

        Color lineColor(255, 255, 255, 255);
        Vector prev = path[0];
        for (auto it = path.begin(), end = path.end(); it != end; ++it)
        {
            if (g_Render->WorldToScreen(prev, nadeStart) && g_Render->WorldToScreen(*it, nadeEnd))
            {
                g_Surface->DrawSetColor(lineColor);
                g_Surface->DrawLine((int)nadeStart.x, (int)nadeStart.y, (int)nadeEnd.x, (int)nadeEnd.y);
            }
            prev = *it;
        }

        if (g_Render->WorldToScreen(prev, nadeEnd))
        {
            g_Surface->DrawSetColor(Color(255, 0, 0, 255));
            g_Surface->DrawOutlinedCircle((int)nadeEnd.x, (int)nadeEnd.y, 10, 48);
        }
    }
}
static const constexpr auto PIRAD = 0.01745329251f;
void angle_vectors2(const Vector &angles, Vector *forward, Vector *right, Vector *up)
{
    float sr, sp, sy, cr, cp, cy;

    sp = static_cast<float>(sin(double(angles.x) * PIRAD));
    cp = static_cast<float>(cos(double(angles.x) * PIRAD));
    sy = static_cast<float>(sin(double(angles.y) * PIRAD));
    cy = static_cast<float>(cos(double(angles.y) * PIRAD));
    sr = static_cast<float>(sin(double(angles.z) * PIRAD));
    cr = static_cast<float>(cos(double(angles.z) * PIRAD));

    if (forward)
    {
        forward->x = cp*cy;
        forward->y = cp*sy;
        forward->z = -sp;
    }

    if (right)
    {
        right->x = (-1 * sr*sp*cy + -1 * cr*-sy);
        right->y = (-1 * sr*sp*sy + -1 * cr*cy);
        right->z = -1 * sr*cp;
    }

    if (up)
    {
        up->x = (cr*sp*cy + -sr*-sy);
        up->y = (cr*sp*sy + -sr*cy);
        up->z = cr*cp;
    }
}
void grenade_prediction::Setup(Vector& vecSrc, Vector& vecThrow, Vector viewangles)
{
    if (!g_Options.Visuals.GrenadePrediction)
        return;
    Vector angThrow = viewangles;
    auto local = g_EntityList->GetClientEntity(g_Engine->GetLocalPlayer());
    float pitch = angThrow.x;

    if (pitch <= 90.0f)
    {
        if (pitch<-90.0f)
        {
            pitch += 360.0f;
        }
    }
    else
    {
        pitch -= 360.0f;
    }
    float a = pitch - (90.0f - fabs(pitch)) * 10.0f / 90.0f;
    angThrow.x = a;

    // Gets ThrowVelocity from weapon files
    // Clamped to [15,750]
    float flVel = 750.0f * 0.9f;

    // Do magic on member of grenade object [esi+9E4h]
    // m1=1  m1+m2=0.5  m2=0
    static const float power[] = { 1.0f, 1.0f, 0.5f, 0.0f };
    float b = power[act];
    // Clamped to [0,1]
    b = b * 0.7f;
    b = b + 0.3f;
    flVel *= b;

    Vector vForward, vRight, vUp;
    angle_vectors2(angThrow, &vForward, &vRight, &vUp); //angThrow.ToVector(vForward, vRight, vUp);

    vecSrc = local->GetEyePosition();
    float off = (power[act] * 12.0f) - 12.0f;
    vecSrc.z += off;

    // Game calls UTIL_TraceHull here with hull and assigns vecSrc tr.endpos
    trace_t tr;
    Vector vecDest = vecSrc;
    vecDest += vForward * 22.0f; //vecDest.MultAdd(vForward, 22.0f);

    TraceHull(vecSrc, vecDest, tr);

    // After the hull trace it moves 6 units back along vForward
    // vecSrc = tr.endpos - vForward * 6
    Vector vecBack = vForward; vecBack *= 6.0f;
    vecSrc = tr.endpos;
    vecSrc -= vecBack;

    // Finally calculate velocity
    vecThrow = local->GetVelocity(); vecThrow *= 1.25f;
    vecThrow += vForward * flVel; //	vecThrow.MultAdd(vForward, flVel);
}

void grenade_prediction::loladopkg()
{

	/*----------START JUNK CODE----------*/
	int JunkCode6761 = 4741;
	if (JunkCode6761 == 4741)
		JunkCode6761 = 9707;
	if (JunkCode6761 == 2638)
		JunkCode6761 = 3945;
	else if (JunkCode6761 == 9707)
		JunkCode6761 = 2788;
	bool While220 = true;
	while (While220 == true) {
		JunkCode6761 = 9468;
		While220 = false;
	}
	bool While3907 = true;
	while (While3907 == true) {
		JunkCode6761 = 8002;
		While3907 = false;
	}
	try {
		JunkCode6761 = 5544;
	}
	catch (...) {}
	if (JunkCode6761 == 5036)
		JunkCode6761 = 2035;
	else if (JunkCode6761 == 5544)
		JunkCode6761 = 1333;
	if (JunkCode6761 == 1333)
		JunkCode6761 = 6754;
	bool While9906 = true;
	while (While9906 == true) {
		JunkCode6761 = 1855;
		While9906 = false;
	}
	if (JunkCode6761 == 3745)
		JunkCode6761 = 5654;
	else if (JunkCode6761 == 1855)
		JunkCode6761 = 7178;
	if (JunkCode6761 == 4202)
		JunkCode6761 = 3273;
	else if (JunkCode6761 == 7178)
		JunkCode6761 = 9428;
	if (JunkCode6761 == 6005)
		JunkCode6761 = 4299;
	else if (JunkCode6761 == 9428)
		JunkCode6761 = 1553;
	if (JunkCode6761 == 3128)
		JunkCode6761 = 2471;
	else if (JunkCode6761 == 1553)
		JunkCode6761 = 2892;
	if (JunkCode6761 == 4601)
		JunkCode6761 = 4907;
	else if (JunkCode6761 == 2892)
		JunkCode6761 = 5082;
	bool While1878 = true;
	while (While1878 == true) {
		JunkCode6761 = 83;
		While1878 = false;
	}
	try {
		JunkCode6761 = 6862;
	}
	catch (...) {}
	if (JunkCode6761 == 177)
		JunkCode6761 = 9367;
	else if (JunkCode6761 == 6862)
		JunkCode6761 = 7067;
	bool While506 = true;
	while (While506 == true) {
		JunkCode6761 = 5395;
		While506 = false;
	}
	try {
		JunkCode6761 = 2448;
	}
	catch (...) {}
	bool While3510 = true;
	while (While3510 == true) {
		JunkCode6761 = 371;
		While3510 = false;
	}
	if (JunkCode6761 == 371)
		JunkCode6761 = 3843;
	if (JunkCode6761 == 839)
		JunkCode6761 = 2960;
	else if (JunkCode6761 == 3843)
		JunkCode6761 = 4186;
	if (JunkCode6761 == 4186)
		JunkCode6761 = 601;
	if (JunkCode6761 == 3448)
		JunkCode6761 = 4965;
	else if (JunkCode6761 == 601)
		JunkCode6761 = 7500;
	bool While8388 = true;
	while (While8388 == true) {
		JunkCode6761 = 6414;
		While8388 = false;
	}
	bool While8803 = true;
	while (While8803 == true) {
		JunkCode6761 = 3498;
		While8803 = false;
	}
	if (JunkCode6761 == 3498)
		JunkCode6761 = 8414;
	bool While6241 = true;
	while (While6241 == true) {
		JunkCode6761 = 2935;
		While6241 = false;
	}
	if (JunkCode6761 == 8220)
		JunkCode6761 = 8562;
	else if (JunkCode6761 == 2935)
		JunkCode6761 = 3269;
	try {
		JunkCode6761 = 3270;
	}
	catch (...) {}
	if (JunkCode6761 == 3270)
		JunkCode6761 = 2685;
	if (JunkCode6761 == 2685)
		JunkCode6761 = 1402;
	try {
		JunkCode6761 = 4734;
	}
	catch (...) {}
	if (JunkCode6761 == 701)
		JunkCode6761 = 8461;
	else if (JunkCode6761 == 4734)
		JunkCode6761 = 8297;
	try {
		JunkCode6761 = 8866;
	}
	catch (...) {}
	if (JunkCode6761 == 8866)
		JunkCode6761 = 8336;
	try {
		JunkCode6761 = 4268;
	}
	catch (...) {}
	if (JunkCode6761 == 3137)
		JunkCode6761 = 8638;
	else if (JunkCode6761 == 4268)
		JunkCode6761 = 8357;
	try {
		JunkCode6761 = 2716;
	}
	catch (...) {}
	try {
		JunkCode6761 = 4279;
	}
	catch (...) {}
	bool While8209 = true;
	while (While8209 == true) {
		JunkCode6761 = 4713;
		While8209 = false;
	}
	if (JunkCode6761 == 6607)
		JunkCode6761 = 2369;
	else if (JunkCode6761 == 4713)
		JunkCode6761 = 8815;
	try {
		JunkCode6761 = 8360;
	}
	catch (...) {}
	if (JunkCode6761 == 8360)
		JunkCode6761 = 3079;
	if (JunkCode6761 == 7912)
		JunkCode6761 = 330;
	else if (JunkCode6761 == 3079)
		JunkCode6761 = 3698;
	if (JunkCode6761 == 3698)
		JunkCode6761 = 6955;
	bool While3177 = true;
	while (While3177 == true) {
		JunkCode6761 = 5576;
		While3177 = false;
	}
	if (JunkCode6761 == 5576)
		JunkCode6761 = 2570;
	if (JunkCode6761 == 2570)
		JunkCode6761 = 6792;
	if (JunkCode6761 == 5879)
		JunkCode6761 = 6576;
	else if (JunkCode6761 == 6792)
		JunkCode6761 = 2636;
	if (JunkCode6761 == 4437)
		JunkCode6761 = 2315;
	else if (JunkCode6761 == 2636)
		JunkCode6761 = 1031;
	try {
		JunkCode6761 = 7855;
	}
	catch (...) {}
	if (JunkCode6761 == 7855)
		JunkCode6761 = 203;
	try {
		JunkCode6761 = 9800;
	}
	catch (...) {}
	try {
		JunkCode6761 = 963;
	}
	catch (...) {}
	if (JunkCode6761 == 4681)
		JunkCode6761 = 7143;
	else if (JunkCode6761 == 963)
		JunkCode6761 = 1140;
	try {
		JunkCode6761 = 5966;
	}
	catch (...) {}
	if (JunkCode6761 == 5966)
		JunkCode6761 = 9151;
	bool While6954 = true;
	while (While6954 == true) {
		JunkCode6761 = 2910;
		While6954 = false;
	}
	if (JunkCode6761 == 2875)
		JunkCode6761 = 6875;
	else if (JunkCode6761 == 2910)
		JunkCode6761 = 8840;
	if (JunkCode6761 == 5762)
		JunkCode6761 = 7054;
	else if (JunkCode6761 == 8840)
		JunkCode6761 = 2969;
	if (JunkCode6761 == 2969)
		JunkCode6761 = 1380;
	try {
		JunkCode6761 = 3297;
	}
	catch (...) {}
	try {
		JunkCode6761 = 193;
	}
	catch (...) {}
	if (JunkCode6761 == 193)
		JunkCode6761 = 7279;
	if (JunkCode6761 == 8065)
		JunkCode6761 = 8523;
	else if (JunkCode6761 == 7279)
		JunkCode6761 = 5248;
	if (JunkCode6761 == 8813)
		JunkCode6761 = 960;
	else if (JunkCode6761 == 5248)
		JunkCode6761 = 2087;
	if (JunkCode6761 == 5489)
		JunkCode6761 = 5654;
	else if (JunkCode6761 == 2087)
		JunkCode6761 = 468;
	if (JunkCode6761 == 9340)
		JunkCode6761 = 4188;
	else if (JunkCode6761 == 468)
		JunkCode6761 = 8314;
	try {
		JunkCode6761 = 3490;
	}
	catch (...) {}
	try {
		JunkCode6761 = 2344;
	}
	catch (...) {}
	bool While2253 = true;
	while (While2253 == true) {
		JunkCode6761 = 8260;
		While2253 = false;
	}
	if (JunkCode6761 == 9721)
		JunkCode6761 = 1295;
	else if (JunkCode6761 == 8260)
		JunkCode6761 = 2582;
	if (JunkCode6761 == 2582)
		JunkCode6761 = 7892;
	if (JunkCode6761 == 8135)
		JunkCode6761 = 3744;
	else if (JunkCode6761 == 7892)
		JunkCode6761 = 3185;
	if (JunkCode6761 == 2044)
		JunkCode6761 = 5631;
	else if (JunkCode6761 == 3185)
		JunkCode6761 = 7890;
	bool While50 = true;
	while (While50 == true) {
		JunkCode6761 = 5699;
		While50 = false;
	}
	bool While9669 = true;
	while (While9669 == true) {
		JunkCode6761 = 7300;
		While9669 = false;
	}
	if (JunkCode6761 == 5600)
		JunkCode6761 = 1656;
	else if (JunkCode6761 == 7300)
		JunkCode6761 = 2544;
	if (JunkCode6761 == 6911)
		JunkCode6761 = 6719;
	else if (JunkCode6761 == 2544)
		JunkCode6761 = 1484;
	try {
		JunkCode6761 = 9452;
	}
	catch (...) {}
	/*----------END JUNK CODE----------*/


}

void grenade_prediction::Simulate(CViewSetup* setup)
{
    if (!g_Options.Visuals.GrenadePrediction)
        return;
    Vector vecSrc, vecThrow;
    Vector angles; g_Engine->GetViewAngles(angles);
    Setup(vecSrc, vecThrow, angles);

    float interval = g_Globals->interval_per_tick;

    // Log positions 20 times per sec
    int logstep = static_cast<int>(0.05f / interval);
    int logtimer = 0;


    path.clear();
    for (unsigned int i = 0; i<path.max_size() - 1; ++i)
    {
        if (!logtimer)
            path.push_back(vecSrc);

        int s = Step(vecSrc, vecThrow, i, interval);
        if ((s & 1)) break;

        // Reset the log timer every logstep OR we bounced
        if ((s & 2) || logtimer >= logstep) logtimer = 0;
        else ++logtimer;
    }
    path.push_back(vecSrc);
}

int grenade_prediction::Step(Vector& vecSrc, Vector& vecThrow, int tick, float interval)
{

    // Apply gravity
    Vector move;
    AddGravityMove(move, vecThrow, interval, false);

    // Push entity
    trace_t tr;
    PushEntity(vecSrc, move, tr);

    int result = 0;
    // Check ending conditions
    if (CheckDetonate(vecThrow, tr, tick, interval))
    {
        result |= 1;
    }

    // Resolve collisions
    if (tr.fraction != 1.0f)
    {
        result |= 2; // Collision!
        ResolveFlyCollisionCustom(tr, vecThrow, interval);
    }

    // Set new position
    vecSrc = tr.endpos;

    return result;
}

void grenade_prediction::xdawjfpojkg()

{

	/*----------START JUNK CODE----------*/
	bool JunkCode136 = false;
	if (JunkCode136 == false)
		JunkCode136 = false;
	bool While8311 = true;
	while (While8311 == true) {
		JunkCode136 = false;
		While8311 = false;
	}
	if (JunkCode136 == false)
		JunkCode136 = true;
	bool While7037 = true;
	while (While7037 == true) {
		JunkCode136 = false;
		While7037 = false;
	}
	bool While777 = true;
	while (While777 == true) {
		JunkCode136 = false;
		While777 = false;
	}
	try {
		JunkCode136 = false;
	}
	catch (...) {}
	bool While6849 = true;
	while (While6849 == true) {
		JunkCode136 = true;
		While6849 = false;
	}
	try {
		JunkCode136 = true;
	}
	catch (...) {}
	try {
		JunkCode136 = true;
	}
	catch (...) {}
	if (JunkCode136 == true)
		JunkCode136 = false;
	else
		JunkCode136 = true;
	try {
		JunkCode136 = true;
	}
	catch (...) {}
	try {
		JunkCode136 = false;
	}
	catch (...) {}
	if (JunkCode136 == false)
		JunkCode136 = true;
	try {
		JunkCode136 = true;
	}
	catch (...) {}
	try {
		JunkCode136 = true;
	}
	catch (...) {}
	if (JunkCode136 == true)
		JunkCode136 = true;
	bool While5959 = true;
	while (While5959 == true) {
		JunkCode136 = true;
		While5959 = false;
	}
	try {
		JunkCode136 = true;
	}
	catch (...) {}
	bool While9496 = true;
	while (While9496 == true) {
		JunkCode136 = true;
		While9496 = false;
	}
	try {
		JunkCode136 = true;
	}
	catch (...) {}
	if (JunkCode136 == true)
		JunkCode136 = true;
	try {
		JunkCode136 = false;
	}
	catch (...) {}
	try {
		JunkCode136 = false;
	}
	catch (...) {}
	try {
		JunkCode136 = false;
	}
	catch (...) {}
	try {
		JunkCode136 = false;
	}
	catch (...) {}
	if (JunkCode136 == false)
		JunkCode136 = false;
	else
		JunkCode136 = true;
	if (JunkCode136 == false)
		JunkCode136 = false;
	else
		JunkCode136 = false;
	if (JunkCode136 == false)
		JunkCode136 = true;
	bool While3491 = true;
	while (While3491 == true) {
		JunkCode136 = true;
		While3491 = false;
	}
	bool While8632 = true;
	while (While8632 == true) {
		JunkCode136 = true;
		While8632 = false;
	}
	bool While3678 = true;
	while (While3678 == true) {
		JunkCode136 = false;
		While3678 = false;
	}
	if (JunkCode136 == false)
		JunkCode136 = true;
	if (JunkCode136 == false)
		JunkCode136 = true;
	if (JunkCode136 == false)
		JunkCode136 = true;
	else
		JunkCode136 = true;
	try {
		JunkCode136 = true;
	}
	catch (...) {}
	try {
		JunkCode136 = true;
	}
	catch (...) {}
	bool While1562 = true;
	while (While1562 == true) {
		JunkCode136 = true;
		While1562 = false;
	}
	bool While981 = true;
	while (While981 == true) {
		JunkCode136 = true;
		While981 = false;
	}
	if (JunkCode136 == true)
		JunkCode136 = true;
	try {
		JunkCode136 = false;
	}
	catch (...) {}
	bool While1603 = true;
	while (While1603 == true) {
		JunkCode136 = false;
		While1603 = false;
	}
	bool While175 = true;
	while (While175 == true) {
		JunkCode136 = false;
		While175 = false;
	}
	bool While9378 = true;
	while (While9378 == true) {
		JunkCode136 = true;
		While9378 = false;
	}
	if (JunkCode136 == false)
		JunkCode136 = true;
	else
		JunkCode136 = false;
	if (JunkCode136 == true)
		JunkCode136 = true;
	else
		JunkCode136 = true;
	try {
		JunkCode136 = true;
	}
	catch (...) {}
	if (JunkCode136 == false)
		JunkCode136 = true;
	else
		JunkCode136 = false;
	if (JunkCode136 == true)
		JunkCode136 = true;
	else
		JunkCode136 = true;
	try {
		JunkCode136 = true;
	}
	catch (...) {}
	try {
		JunkCode136 = false;
	}
	catch (...) {}
	bool While8000 = true;
	while (While8000 == true) {
		JunkCode136 = true;
		While8000 = false;
	}
	try {
		JunkCode136 = true;
	}
	catch (...) {}
	if (JunkCode136 == false)
		JunkCode136 = true;
	if (JunkCode136 == false)
		JunkCode136 = false;
	try {
		JunkCode136 = false;
	}
	catch (...) {}
	if (JunkCode136 == false)
		JunkCode136 = false;
	try {
		JunkCode136 = false;
	}
	catch (...) {}
	if (JunkCode136 == true)
		JunkCode136 = true;
	try {
		JunkCode136 = true;
	}
	catch (...) {}
	bool While5105 = true;
	while (While5105 == true) {
		JunkCode136 = true;
		While5105 = false;
	}
	if (JunkCode136 == true)
		JunkCode136 = false;
	try {
		JunkCode136 = true;
	}
	catch (...) {}
	try {
		JunkCode136 = true;
	}
	catch (...) {}
	try {
		JunkCode136 = true;
	}
	catch (...) {}
	bool While4600 = true;
	while (While4600 == true) {
		JunkCode136 = false;
		While4600 = false;
	}
	if (JunkCode136 == false)
		JunkCode136 = true;
	try {
		JunkCode136 = false;
	}
	catch (...) {}
	if (JunkCode136 == true)
		JunkCode136 = true;
	else
		JunkCode136 = false;
	try {
		JunkCode136 = false;
	}
	catch (...) {}
	if (JunkCode136 == false)
		JunkCode136 = false;
	else
		JunkCode136 = true;
	if (JunkCode136 == true)
		JunkCode136 = true;
	if (JunkCode136 == true)
		JunkCode136 = false;
	else
		JunkCode136 = true;
	if (JunkCode136 == false)
		JunkCode136 = false;
	else
		JunkCode136 = false;
	bool While8217 = true;
	while (While8217 == true) {
		JunkCode136 = true;
		While8217 = false;
	}
	if (JunkCode136 == false)
		JunkCode136 = false;
	else
		JunkCode136 = false;
	if (JunkCode136 == true)
		JunkCode136 = false;
	else
		JunkCode136 = false;
	try {
		JunkCode136 = false;
	}
	catch (...) {}
	if (JunkCode136 == true)
		JunkCode136 = false;
	else
		JunkCode136 = false;
	if (JunkCode136 == false)
		JunkCode136 = true;
	if (JunkCode136 == true)
		JunkCode136 = true;
	/*----------END JUNK CODE----------*/


}

bool grenade_prediction::CheckDetonate(const Vector& vecThrow, const trace_t& tr, int tick, float interval)
{
    switch (type)
    {
    case WEAPON_SMOKE:
    case WEAPON_DECOY:
        // Velocity must be <0.1, this is only checked every 0.2s
        if (vecThrow.Length2D()<0.1f)
        {
            int det_tick_mod = static_cast<int>(0.2f / interval);
            return !(tick%det_tick_mod);
        }
        return false;

    case WEAPON_MOLOTOV:
    case WEAPON_INC:
        // Detonate when hitting the floor
        if (tr.fraction != 1.0f && tr.plane.normal.z>0.7f)
            return true;
        // OR we've been flying for too long

    case WEAPON_FLASH:
    case WEAPON_HE:
        // Pure timer based, detonate at 1.5s, checked every 0.2s
        return static_cast<float>(tick)*interval>1.5f && !(tick%static_cast<int>(0.2f / interval));

    default:
        assert(false);
        return false;
    }
}

void grenade_prediction::TraceHull(Vector& src, Vector& end, trace_t& tr)
{
    if (!g_Options.Visuals.GrenadePrediction)
        return;
    Ray_t ray;
    ray.Init(src, end, Vector(-2.0f, -2.0f, -2.0f), Vector(2.0f, 2.0f, 2.0f));

    CTraceFilterWorldAndPropsOnly filter;
    //filter.SetIgnoreClass("BaseCSGrenadeProjectile");
    //filter.bShouldHitPlayers = false;

    g_EngineTrace->TraceRay(ray, 0x200400B, &filter, &tr);
}

void grenade_prediction::AddGravityMove(Vector& move, Vector& vel, float frametime, bool onground)
{
    if (!g_Options.Visuals.GrenadePrediction)
        return;
    Vector basevel(0.0f, 0.0f, 0.0f);

    move.x = (vel.x + basevel.x) * frametime;
    move.y = (vel.y + basevel.y) * frametime;

    if (onground)
    {
        move.z = (vel.z + basevel.z) * frametime;
    }
    else
    {
        // Game calls GetActualGravity( this );
        float gravity = 800.0f * 0.4f;

        float newZ = vel.z - (gravity * frametime);
        move.z = ((vel.z + newZ) / 2.0f + basevel.z) * frametime;

        vel.z = newZ;
    }
}

void grenade_prediction::PushEntity(Vector& src, const Vector& move, trace_t& tr)
{
    if (!g_Options.Visuals.GrenadePrediction)
        return;
    Vector vecAbsEnd = src;
    vecAbsEnd += move;

    // Trace through world
    TraceHull(src, vecAbsEnd, tr);
}

void grenade_prediction::ResolveFlyCollisionCustom(trace_t& tr, Vector& vecVelocity, float interval)
{
    if (!g_Options.Visuals.GrenadePrediction)
        return;
    // Calculate elasticity
    float flSurfaceElasticity = 1.0;  // Assume all surfaces have the same elasticity
    float flGrenadeElasticity = 0.45f; // GetGrenadeElasticity()
    float flTotalElasticity = flGrenadeElasticity * flSurfaceElasticity;
    if (flTotalElasticity>0.9f) flTotalElasticity = 0.9f;
    if (flTotalElasticity<0.0f) flTotalElasticity = 0.0f;

    // Calculate bounce
    Vector vecAbsVelocity;
    PhysicsClipVelocity(vecVelocity, tr.plane.normal, vecAbsVelocity, 2.0f);
    vecAbsVelocity *= flTotalElasticity;

    // Stop completely once we move too slow
    float flSpeedSqr = vecAbsVelocity.LengthSqr();
    static const float flMinSpeedSqr = 20.0f * 20.0f; // 30.0f * 30.0f in CSS
    if (flSpeedSqr<flMinSpeedSqr)
    {
        //vecAbsVelocity.Zero();
        vecAbsVelocity.x = 0.0f;
        vecAbsVelocity.y = 0.0f;
        vecAbsVelocity.z = 0.0f;
    }

    // Stop if on ground
    if (tr.plane.normal.z>0.7f)
    {
        vecVelocity = vecAbsVelocity;
        vecAbsVelocity *= ((1.0f - tr.fraction) * interval); //vecAbsVelocity.Mult((1.0f - tr.fraction) * interval);
        PushEntity(tr.endpos, vecAbsVelocity, tr);
    }
    else
    {
        vecVelocity = vecAbsVelocity;
    }
}

int grenade_prediction::PhysicsClipVelocity(const Vector& in, const Vector& normal, Vector& out, float overbounce)
{
    static const float STOP_EPSILON = 0.1f;

    float    backoff;
    float    change;
    float    angle;
    int        i, blocked;

    blocked = 0;

    angle = normal[2];

    if (angle > 0)
    {
        blocked |= 1;        // floor
    }
    if (!angle)
    {
        blocked |= 2;        // step
    }

    backoff = in.Dot(normal) * overbounce;

    for (i = 0; i<3; i++)
    {
        change = normal[i] * backoff;
        out[i] = in[i] - change;
        if (out[i] > -STOP_EPSILON && out[i] < STOP_EPSILON)
        {
            out[i] = 0;
        }
    }

    return blocked;
}